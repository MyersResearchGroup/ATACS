///////////////////////////////////////////////////////////////////////////////
// @name Timed Asynchronous Circuit Optimization  
// @version 0.1 alpha
//
// (c)opyright 1998 by Eric G. Mercer
//
// @author Eric G. Mercer
//                    
// Permission to use, copy, modify and/or distribute, but not sell, this  
// software and its documentation for any purpose is hereby granted       
// without fee, subject to the following terms and conditions:            
//                                                                          
// 1. The above copyright notice and this permission notice must         
// appear in all copies of the software and related documentation.        
//                                                                          
// 2. The name of University of Utah may not be used in advertising or  
// publicity pertaining to distribution of the software without the       
// specific, prior written permission of Univsersity of Utah.
//                                                                          
// 3. This software may not be called "Taco" if it has been modified    
// in any way, without the specific prior written permission of           
// Eric G. Mercer                                
//                                                                          
// 4. THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
// EXPRESS, IMPLIED, OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY       
// WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.       
//                                                                          
// IN NO EVENT SHALL THE UNIVERSITY OF UTAH OR THE AUTHORS OF THIS 
// SOFTWARE BE LIABLE FOR ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL 
// DAMAGES OF ANY KIND, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
// DATA OR PROFITS, WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON
// ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE  
// OR PERFORMANCE OF THIS SOFTWARE.                                            
///////////////////////////////////////////////////////////////////////////////
#ifndef __INTERNAL_PARTITION_H
#define __INTERNAL_PARTITION_H

#undef MAXINT
#include <list>

#include "CPdf.h"

///////////////////////////////////////////////////////////////////////////////
// These typedefs must be woven into bm_trans_prob so as to avoid mutiple 
// definitions of the same thing.
///////////////////////////////////////////////////////////////////////////////
typedef list<const CPdf*>   event_list;
typedef pair<unsigned int,const CPdf*> trans_type;
typedef list<trans_type> trans_list;

///////////////////////////////////////////////////////////////////////////////
//

///////////////////////////////////////////////////////////////////////////////
// This is a class to just collect the upper and lower bounds into a cute 
// little package.  I put enough in there to make it a solid data type,
// but not so much that its bloated. 
/////////////////////////////////////////////////////////////////////////////
class bound_type {
protected:
  
  unsigned int m_lower;
  unsigned int m_upper;
  
public:

  /////////////////////////////////////////////////////////////////////////////
  // Void constructor
  /////////////////////////////////////////////////////////////////////////////
  bound_type();

  /////////////////////////////////////////////////////////////////////////////
  // Sets m_lower, m_upper to l and b repsectively.
  /////////////////////////////////////////////////////////////////////////////
  bound_type( const unsigned int l, const unsigned int u );

  /////////////////////////////////////////////////////////////////////////////
  // Copy Constructor
  /////////////////////////////////////////////////////////////////////////////
  bound_type( const bound_type& b );

  /////////////////////////////////////////////////////////////////////////////
  // Assignment Operator
  /////////////////////////////////////////////////////////////////////////////
  bound_type& operator=( const bound_type& b );

  /////////////////////////////////////////////////////////////////////////////
  // Returns the lower bound value.
  /////////////////////////////////////////////////////////////////////////////
  const unsigned int lower() const;
  
  /////////////////////////////////////////////////////////////////////////////
  // Returns the upper bound value
  /////////////////////////////////////////////////////////////////////////////
  const unsigned int upper() const;

  /////////////////////////////////////////////////////////////////////////////
  // Sets the value of the lower bound to i
  /////////////////////////////////////////////////////////////////////////////
  void lower( const unsigned int& i );
  
  /////////////////////////////////////////////////////////////////////////////
  // Sets the value of the upper bound to i
  /////////////////////////////////////////////////////////////////////////////
  void upper( const unsigned int& i );
  
};

/////////////////////////////////////////////////////////////////////////////
// outputs a bound_type in its text form: <l,u>
/////////////////////////////////////////////////////////////////////////////
ostream& operator<<( ostream& s, const bound_type& b );


//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//

/////////////////////////////////////////////////////////////////////////////
// A partition is a bound representing the timer range with a set of
// probabiltiy distribution functions that fall into two seperate lists:
// pdfs whose associated event has occured, and those whose associated event
// is enabled to occur.  The first is a CPdf* and the second is a 
// a transition_type object which is a integer representing the state number
// of the system after the event and a CPdf* showing the fire time distrib-
// ution of the event.  The function has three overloaded () operators: 1: 
// to insert transistion_type objects 2: To insert CPdf* type objects and
// 3: To set the value of the partition_type's bound. Other functions
// return the const references to the enabled and fired lists.
/////////////////////////////////////////////////////////////////////////////
class partition_type {
protected:
  
  bound_type m_bounds;    // Bounds for this parition
  trans_list m_Enabled;   // Events enabled to fire in this partition
  event_list m_Fired;     // Events that have fired in this partition

public:
  
  /////////////////////////////////////////////////////////////////////////////
  // Constructs a new partition_type with bounds b and empty fired and 
  // enabled lists.
  /////////////////////////////////////////////////////////////////////////////
  partition_type( const bound_type& b );

  /////////////////////////////////////////////////////////////////////////////
  // Constructs a new parition_type with bounds b, enabled list t, and 
  // fired list f.
  /////////////////////////////////////////////////////////////////////////////
  partition_type( const bound_type& b, 
		  const trans_list& t,
		  const event_list& f );

  /////////////////////////////////////////////////////////////////////////////
  // Copy Constructor
  /////////////////////////////////////////////////////////////////////////////
  partition_type( const partition_type& p );

  /////////////////////////////////////////////////////////////////////////////
  // assignment operator
  /////////////////////////////////////////////////////////////////////////////
  partition_type& operator=( const partition_type& p );

  /////////////////////////////////////////////////////////////////////////////
  // Adds transition_type t to the enabled list.
  /////////////////////////////////////////////////////////////////////////////
  void operator()( const trans_type& t );

  /////////////////////////////////////////////////////////////////////////////
  // Addes CPdf* c to the fired list.
  /////////////////////////////////////////////////////////////////////////////
  void operator()( const CPdf* c );

  /////////////////////////////////////////////////////////////////////////////
  // Replaces the bounds for this parition_type with b.
  /////////////////////////////////////////////////////////////////////////////
  void operator()( const bound_type& b );

  /////////////////////////////////////////////////////////////////////////////
  // Returns a constant reference enabled list.
  /////////////////////////////////////////////////////////////////////////////
  const trans_list& enabled() const;

  /////////////////////////////////////////////////////////////////////////////
  // Returns a constant reference to the fired list.
  /////////////////////////////////////////////////////////////////////////////
  const event_list& fired() const;

  /////////////////////////////////////////////////////////////////////////////
  // Returns a constant reference to the bound_type representing the bounds
  // for this paritions.
  /////////////////////////////////////////////////////////////////////////////
  const bound_type& bounds() const;

};

/////////////////////////////////////////////////////////////////////////////
// Outputs the ascii text representation of the parition_type p to the stream
// s.  The partition is displayed as follow:
// Partition <l,u>
//   E -> ...
//        ...
//   F -> ...
//        ...
/////////////////////////////////////////////////////////////////////////////
ostream& operator<<( ostream& s, const partition_type& p );

//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//

/////////////////////////////////////////////////////////////////////////////
// partition_list is a class used to keep track of partition_types.  Its most
// important functions are adjust_global_range and adjust_paritions, called 
// whenever a new transition_type or CPdf* is added to the partition list.
// This purpose of this class to order transition_types and CPdf*s into 
// itersecting/non-intersecting partitions as they are added.  In this way,
// when trying to calculate integrals, the integration function can begen
// and end its calculation on the discontinuity points, which occure at the
// bounds of the partition_types in the partition_list.  User interface
// consists of the overloaded () operators for adding new items to the part-
// ition_list and the begin()/end() functions that give access to the
// internal list of partition_types.
/////////////////////////////////////////////////////////////////////////////
class partition_list {
protected:

  typedef list<partition_type>       part_list;
  typedef part_list::const_iterator  const_iterator;
  typedef part_list::iterator        iterator;

  bound_type m_bounds; // Overal global bounds of the entire partition_list
  part_list m_plist;   // Actual list of parition_types

protected:

  /////////////////////////////////////////////////////////////////////////////
  // Functions adjusts the global bounds in this partition to be the <min,max>
  // bounds of all of the types contained in this list.
  /////////////////////////////////////////////////////////////////////////////
  void adjust_global_range( const bound_type& b, bool lower_only = false );

  /////////////////////////////////////////////////////////////////////////////
  // adjust_partitions divides and adds new parition_types into this partition-
  // list depending on the bound_type b.  Complexity is O(n) where n is the
  // number of partition_types currently in the list. 
  /////////////////////////////////////////////////////////////////////////////
  void adjust_partitions( bound_type b );

public:

  /////////////////////////////////////////////////////////////////////////////
  // Void constructor
  /////////////////////////////////////////////////////////////////////////////
  partition_list();

  /////////////////////////////////////////////////////////////////////////////
  // Copy constructor
  /////////////////////////////////////////////////////////////////////////////
  partition_list( const partition_list& p );

  /////////////////////////////////////////////////////////////////////////////
  // Addes CPdf* into 'this' partition_list
  /////////////////////////////////////////////////////////////////////////////
  void operator()( const CPdf* c );

  /////////////////////////////////////////////////////////////////////////////
  // Adds transition_type t into this partition list.
  /////////////////////////////////////////////////////////////////////////////
  void operator()( const trans_type& t );

  /////////////////////////////////////////////////////////////////////////////
  // Returns a const_iterator to the beginning of the partition_type list
  ////////////////////////////////////////////////////////////////////////////
  const_iterator begin() const;
  
  /////////////////////////////////////////////////////////////////////////////
  // Returns a const_iterator to the end of the partition_type list.
  /////////////////////////////////////////////////////////////////////////////
  const_iterator end() const;

  /////////////////////////////////////////////////////////////////////////////
  // returns the bounds of the partition
  /////////////////////////////////////////////////////////////////////////////
  bound_type bounds() const;

  /////////////////////////////////////////////////////////////////////////////
  // Returns a const_iterator to the position in the partition_list that
  // is 1 location past the partition that matches the global upper bound.  
  // A range from first to bounded_end() covers [first,bounded_end()), meaning
  // the bounded_end() is not included in the range.
  /////////////////////////////////////////////////////////////////////////////
  const_iterator bounded_end() const;

};

//
///////////////////////////////////////////////////////////////////////////////

#endif // __INTERNAL_PARTITION_H
